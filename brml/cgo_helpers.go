// Copyright 2024 Shanghai Biren Technology Co., Ltd.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// WARNING: This file has automatically been generated on Wed, 10 Apr 2024 10:50:21 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package brml

/*
#cgo LDFLAGS: -Wl,--unresolved-symbols=ignore-in-object-files
#include "brml.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *PciInfo) Ref() *C.brmlPciInfo_t {
	if x == nil {
		return nil
	}
	return (*C.brmlPciInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PciInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPciInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewPciInfoRef(ref unsafe.Pointer) *PciInfo {
	return (*PciInfo)(ref)
}

// NewPciInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPciInfo() *PciInfo {
	return (*PciInfo)(allocPciInfoMemory(1))
}

// allocPciInfoMemory allocates memory for type C.brmlPciInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPciInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPciInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPciInfoValue = unsafe.Sizeof([1]C.brmlPciInfo_t{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PciInfo) PassRef() *C.brmlPciInfo_t {
	if x == nil {
		x = (*PciInfo)(allocPciInfoMemory(1))
	}
	return (*C.brmlPciInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PciErrorCounter) Ref() *C.brmlPciErrorCounter_t {
	if x == nil {
		return nil
	}
	return (*C.brmlPciErrorCounter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PciErrorCounter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPciErrorCounterRef converts the C object reference into a raw struct reference without wrapping.
func NewPciErrorCounterRef(ref unsafe.Pointer) *PciErrorCounter {
	return (*PciErrorCounter)(ref)
}

// NewPciErrorCounter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPciErrorCounter() *PciErrorCounter {
	return (*PciErrorCounter)(allocPciErrorCounterMemory(1))
}

// allocPciErrorCounterMemory allocates memory for type C.brmlPciErrorCounter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPciErrorCounterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPciErrorCounterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPciErrorCounterValue = unsafe.Sizeof([1]C.brmlPciErrorCounter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PciErrorCounter) PassRef() *C.brmlPciErrorCounter_t {
	if x == nil {
		x = (*PciErrorCounter)(allocPciErrorCounterMemory(1))
	}
	return (*C.brmlPciErrorCounter_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *EccErrorCounts) Ref() *C.brmlEccErrorCounts_t {
	if x == nil {
		return nil
	}
	return (*C.brmlEccErrorCounts_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *EccErrorCounts) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewEccErrorCountsRef converts the C object reference into a raw struct reference without wrapping.
func NewEccErrorCountsRef(ref unsafe.Pointer) *EccErrorCounts {
	return (*EccErrorCounts)(ref)
}

// NewEccErrorCounts allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewEccErrorCounts() *EccErrorCounts {
	return (*EccErrorCounts)(allocEccErrorCountsMemory(1))
}

// allocEccErrorCountsMemory allocates memory for type C.brmlEccErrorCounts_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEccErrorCountsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEccErrorCountsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEccErrorCountsValue = unsafe.Sizeof([1]C.brmlEccErrorCounts_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *EccErrorCounts) PassRef() *C.brmlEccErrorCounts_t {
	if x == nil {
		x = (*EccErrorCounts)(allocEccErrorCountsMemory(1))
	}
	return (*C.brmlEccErrorCounts_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Utilization) Ref() *C.brmlUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.brmlUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Utilization) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewUtilizationRef converts the C object reference into a raw struct reference without wrapping.
func NewUtilizationRef(ref unsafe.Pointer) *Utilization {
	return (*Utilization)(ref)
}

// NewUtilization allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewUtilization() *Utilization {
	return (*Utilization)(allocUtilizationMemory(1))
}

// allocUtilizationMemory allocates memory for type C.brmlUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUtilizationValue = unsafe.Sizeof([1]C.brmlUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Utilization) PassRef() *C.brmlUtilization_t {
	if x == nil {
		x = (*Utilization)(allocUtilizationMemory(1))
	}
	return (*C.brmlUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *GpuUtilization) Ref() *C.brmlGpuUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.brmlGpuUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *GpuUtilization) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewGpuUtilizationRef converts the C object reference into a raw struct reference without wrapping.
func NewGpuUtilizationRef(ref unsafe.Pointer) *GpuUtilization {
	return (*GpuUtilization)(ref)
}

// NewGpuUtilization allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewGpuUtilization() *GpuUtilization {
	return (*GpuUtilization)(allocGpuUtilizationMemory(1))
}

// allocGpuUtilizationMemory allocates memory for type C.brmlGpuUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGpuUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGpuUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGpuUtilizationValue = unsafe.Sizeof([1]C.brmlGpuUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *GpuUtilization) PassRef() *C.brmlGpuUtilization_t {
	if x == nil {
		x = (*GpuUtilization)(allocGpuUtilizationMemory(1))
	}
	return (*C.brmlGpuUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Memory) Ref() *C.brmlMemory_t {
	if x == nil {
		return nil
	}
	return (*C.brmlMemory_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Memory) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMemoryRef converts the C object reference into a raw struct reference without wrapping.
func NewMemoryRef(ref unsafe.Pointer) *Memory {
	return (*Memory)(ref)
}

// NewMemory allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMemory() *Memory {
	return (*Memory)(allocMemoryMemory(1))
}

// allocMemoryMemory allocates memory for type C.brmlMemory_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryValue = unsafe.Sizeof([1]C.brmlMemory_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Memory) PassRef() *C.brmlMemory_t {
	if x == nil {
		x = (*Memory)(allocMemoryMemory(1))
	}
	return (*C.brmlMemory_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ProcessInfo) Ref() *C.brmlProcessInfo_t {
	if x == nil {
		return nil
	}
	return (*C.brmlProcessInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ProcessInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewProcessInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewProcessInfoRef(ref unsafe.Pointer) *ProcessInfo {
	return (*ProcessInfo)(ref)
}

// NewProcessInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewProcessInfo() *ProcessInfo {
	return (*ProcessInfo)(allocProcessInfoMemory(1))
}

// allocProcessInfoMemory allocates memory for type C.brmlProcessInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProcessInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProcessInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfProcessInfoValue = unsafe.Sizeof([1]C.brmlProcessInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ProcessInfo) PassRef() *C.brmlProcessInfo_t {
	if x == nil {
		x = (*ProcessInfo)(allocProcessInfoMemory(1))
	}
	return (*C.brmlProcessInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *GPUInfo) Ref() *C.brmlGPUInfo_t {
	if x == nil {
		return nil
	}
	return (*C.brmlGPUInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *GPUInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewGPUInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewGPUInfoRef(ref unsafe.Pointer) *GPUInfo {
	return (*GPUInfo)(ref)
}

// NewGPUInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewGPUInfo() *GPUInfo {
	return (*GPUInfo)(allocGPUInfoMemory(1))
}

// allocGPUInfoMemory allocates memory for type C.brmlGPUInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGPUInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGPUInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGPUInfoValue = unsafe.Sizeof([1]C.brmlGPUInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *GPUInfo) PassRef() *C.brmlGPUInfo_t {
	if x == nil {
		x = (*GPUInfo)(allocGPUInfoMemory(1))
	}
	return (*C.brmlGPUInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ProcessUtilizationSample) Ref() *C.brmlProcessUtilizationSample_t {
	if x == nil {
		return nil
	}
	return (*C.brmlProcessUtilizationSample_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ProcessUtilizationSample) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewProcessUtilizationSampleRef converts the C object reference into a raw struct reference without wrapping.
func NewProcessUtilizationSampleRef(ref unsafe.Pointer) *ProcessUtilizationSample {
	return (*ProcessUtilizationSample)(ref)
}

// NewProcessUtilizationSample allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewProcessUtilizationSample() *ProcessUtilizationSample {
	return (*ProcessUtilizationSample)(allocProcessUtilizationSampleMemory(1))
}

// allocProcessUtilizationSampleMemory allocates memory for type C.brmlProcessUtilizationSample_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProcessUtilizationSampleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProcessUtilizationSampleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfProcessUtilizationSampleValue = unsafe.Sizeof([1]C.brmlProcessUtilizationSample_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ProcessUtilizationSample) PassRef() *C.brmlProcessUtilizationSample_t {
	if x == nil {
		x = (*ProcessUtilizationSample)(allocProcessUtilizationSampleMemory(1))
	}
	return (*C.brmlProcessUtilizationSample_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *EventData) Ref() *C.brmlEventData_t {
	if x == nil {
		return nil
	}
	return (*C.brmlEventData_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *EventData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewEventDataRef converts the C object reference into a raw struct reference without wrapping.
func NewEventDataRef(ref unsafe.Pointer) *EventData {
	return (*EventData)(ref)
}

// NewEventData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewEventData() *EventData {
	return (*EventData)(allocEventDataMemory(1))
}

// allocEventDataMemory allocates memory for type C.brmlEventData_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEventDataValue = unsafe.Sizeof([1]C.brmlEventData_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *EventData) PassRef() *C.brmlEventData_t {
	if x == nil {
		x = (*EventData)(allocEventDataMemory(1))
	}
	return (*C.brmlEventData_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PowerSamples) Ref() *C.brmlPowerSamples_t {
	if x == nil {
		return nil
	}
	return (*C.brmlPowerSamples_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PowerSamples) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPowerSamplesRef converts the C object reference into a raw struct reference without wrapping.
func NewPowerSamplesRef(ref unsafe.Pointer) *PowerSamples {
	return (*PowerSamples)(ref)
}

// NewPowerSamples allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPowerSamples() *PowerSamples {
	return (*PowerSamples)(allocPowerSamplesMemory(1))
}

// allocPowerSamplesMemory allocates memory for type C.brmlPowerSamples_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPowerSamplesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPowerSamplesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPowerSamplesValue = unsafe.Sizeof([1]C.brmlPowerSamples_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PowerSamples) PassRef() *C.brmlPowerSamples_t {
	if x == nil {
		x = (*PowerSamples)(allocPowerSamplesMemory(1))
	}
	return (*C.brmlPowerSamples_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *P2pStatus) Ref() *C.brmlP2pStatus_t {
	if x == nil {
		return nil
	}
	return (*C.brmlP2pStatus_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *P2pStatus) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewP2pStatusRef converts the C object reference into a raw struct reference without wrapping.
func NewP2pStatusRef(ref unsafe.Pointer) *P2pStatus {
	return (*P2pStatus)(ref)
}

// NewP2pStatus allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewP2pStatus() *P2pStatus {
	return (*P2pStatus)(allocP2pStatusMemory(1))
}

// allocP2pStatusMemory allocates memory for type C.brmlP2pStatus_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocP2pStatusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfP2pStatusValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfP2pStatusValue = unsafe.Sizeof([1]C.brmlP2pStatus_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *P2pStatus) PassRef() *C.brmlP2pStatus_t {
	if x == nil {
		x = (*P2pStatus)(allocP2pStatusMemory(1))
	}
	return (*C.brmlP2pStatus_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *P2pThroughput) Ref() *C.brmlP2pThroughput_t {
	if x == nil {
		return nil
	}
	return (*C.brmlP2pThroughput_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *P2pThroughput) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewP2pThroughputRef converts the C object reference into a raw struct reference without wrapping.
func NewP2pThroughputRef(ref unsafe.Pointer) *P2pThroughput {
	return (*P2pThroughput)(ref)
}

// NewP2pThroughput allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewP2pThroughput() *P2pThroughput {
	return (*P2pThroughput)(allocP2pThroughputMemory(1))
}

// allocP2pThroughputMemory allocates memory for type C.brmlP2pThroughput_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocP2pThroughputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfP2pThroughputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfP2pThroughputValue = unsafe.Sizeof([1]C.brmlP2pThroughput_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *P2pThroughput) PassRef() *C.brmlP2pThroughput_t {
	if x == nil {
		x = (*P2pThroughput)(allocP2pThroughputMemory(1))
	}
	return (*C.brmlP2pThroughput_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MemoryBandwidth) Ref() *C.brmlMemoryBandwidth_t {
	if x == nil {
		return nil
	}
	return (*C.brmlMemoryBandwidth_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MemoryBandwidth) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMemoryBandwidthRef converts the C object reference into a raw struct reference without wrapping.
func NewMemoryBandwidthRef(ref unsafe.Pointer) *MemoryBandwidth {
	return (*MemoryBandwidth)(ref)
}

// NewMemoryBandwidth allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMemoryBandwidth() *MemoryBandwidth {
	return (*MemoryBandwidth)(allocMemoryBandwidthMemory(1))
}

// allocMemoryBandwidthMemory allocates memory for type C.brmlMemoryBandwidth_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBandwidthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBandwidthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryBandwidthValue = unsafe.Sizeof([1]C.brmlMemoryBandwidth_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MemoryBandwidth) PassRef() *C.brmlMemoryBandwidth_t {
	if x == nil {
		x = (*MemoryBandwidth)(allocMemoryBandwidthMemory(1))
	}
	return (*C.brmlMemoryBandwidth_t)(unsafe.Pointer(x))
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}
